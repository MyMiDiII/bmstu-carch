\chapter{Практическая часть}

В данном разделе представлен ход выполнения лабораторной работы.

\section{Функции ядра по индивидуальному варианту}

На листинге \ref{lst:NP} представлен код функции ядра без оптимизаций, на
листинге \ref{lst:pipe} -- код функции ядра с конвейерной опитимизацией, на
листинге \ref{lst:unroll} -- код функции ядра с развернутым циклом, на листинге
\ref{lst:PU} -- код функции ядра с конвейерной опитимизацией и развернутым
циклом.

\mybreaklisting{Программа варианта без
оптимизаций}{NP}{1-12}{app_no_pragmas.cpp}

\mybreaklisting{Программа варианта с конвейерной
организацией}{pipe}{1-13}{app_pipelined.cpp}

\mybreaklisting{Программа варианта с разворачиванием
цикла}{unroll}{1-13}{app_unrolled.cpp}

\mybreaklisting{Программа варианта c конвейерной организацией и
разворачиванием}{PU}{1-13}{app_pipe_unroll.cpp}

\section{Вариант сборки Emulation-SW}

На листинге \ref{lst:ESW} представлены результат работы приложения в режиме Emulation-SW.

\mybreaklisting{Результаты Emulation-SW}{ESW}{1-21}{swRes.txt}

\section{Вариант сборки Emulation-HW}

На рисунках \ref{img:HWK1}-\ref{img:HWK2} представлена копия экрана
\textbf{Assistant View} для варианта сборки \textbf{Emulation-HW}. На листинге
\ref{lst:EHW} представлены результаты работы приложения в данном варианте
сборки. На рисунке \ref{img:EHWD} представлена копия окна внутрисхемного
отладчика Vivado.

\img{50mm}{hweKernels1}{Копия экрана Assistant View для Emulation-HW (часть
1)}{HWK1}

\img{40mm}{hweKernels2}{Копия экрана Assistant View для Emulation-HW (часть
2)}{HWK2}

\mybreaklisting{Результаты Emulation-HW}{EHW}{1-79}{hwEmRes.txt}

\img{85mm}{hwEmDiag}{Окно внутрисхемного отладчика Vivado для сборки в режиме
Emulation-HW}{EHWD}

\section{Вариант сборки Hardware}

На листинге \ref{lst:HW} представлен результат работы приложения в режиме
Hardware. На~~рисунках~~\ref{img:sum}-\ref{img:HLSPU}~~представлены копии
экрана для вкладок «Summary», «System Diagram», «Platform Diagram» и четыре
вкладки «HLS Synthesis» для каждого ядра сборки Hardware в соответствующем
порядке.

\mybreaklisting{Результаты Hardware}{HW}{1-21}{hwRes.txt}

\img{65mm}{hwSummary}{Копия экрана вкладки Summary}{sum}
\img{70mm}{hwSystemDiag}{Копия экрана вкладки System Diagram}{sysd}
\img{70mm}{hwPlatformDiag}{Копия экрана вкладки Platform Diagram}{platd}
\img{25mm}{hwHLSnoPr}{Копия экрана вкладки HLS Synthesis (без прагм)}{HLSNP}
\img{25mm}{hwHLSpipeline}{Копия экрана вкладки HLS Synthesis (конвейер)}{HLSP}
\img{25mm}{hwHLSunroll}{Копия экрана вкладки HLS Synthesis
(разворачивание)}{HLSU}
\img{25mm}{hwHLSpipeunroll}{Копия экрана вкладки HLS Synthesis (конвейер +
разворачивание)}{HLSPU}

\clearpage
\section{Вывод}

По представленным результатам работы приложения в различных вариантах сборки
можно сделать следующие выводы:
\begin{itemize}
    \item при компиляции кода ядра для работы на ЦПУ хост-системы с помощью
          прагм оптимизации удалось уменьшить время обработки массива, при этом
          конвейеризация дала уменьшение временив 5 раз, развернутый цикл дал
          выигрыш только 1.7 раза, а совмещение методов оптимации -- в 4 раза
          (что объясняется значительным уменьшением времени обработки за счет
          конвейерной обработки и незначительным увеличеним за счет
          развернутого цикла);
    \item при компиляции кода ядра в аппаратную модель и её запуске в
          специальном симуляторе на ЦПУ, время обработки массива значетельно
          увеличилось по сравнению с работой приложения на ЦПУ хост-системы,
          такие результаты можно объянить собственно наличием посредника для
          выполнения приложения;
    \item при компиляции кода ядра в аппаратную модель и её реализации на FPGA
          не удалось достичь оптимизации по времени выполнения: конвейрная
          реализация работает только в 1.02 раза быстрее реализции без
          оптимизаций, при этом обе реализации с развернутым циклом работают в
          13-18 раз медленнее реализации без оптимизаций, что можно объяснить
          замедлением загрузки данных из памяти для данного индивидуального
          задания при развертке цикла, а также использованием автоматической
          развертки цикла.
\end{itemize}

Таким образом, с помощью ускорителя вычислений была достигнута незначительная оптимизация при конвейерной реализации программы, то есть необходима дальнейшая работа по оптимизации кода программы индивидуального варианта.
