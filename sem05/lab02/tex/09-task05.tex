\chapter{Задание 5}

\section{Проверка результата}

Значение регистра x31 представлено на рисунке \ref{img:res}. Значение равно 25
в шестнадцатиричной системе, что соответствует значению 37 в десятиричной
системе счисления, приведенном в задании 1.

\img{15mm}{res}{Проверка значения регистра \texttt{x31}}{res}

\section{Временные диаграммы сигналов стадий выполнения}

В данном подразделе представлены временные диаграммы сигналов стадий выполнения
сигналов команды \texttt{add x31, x31, x2}, находящейся по адресу
\texttt{0x80000014} (на первой итерации).

На рисунке \ref{img:fetch} представлены временные диаграммы сигналов
стадий выборки и диспетчеризации.
На рисунке \ref{img:decode} представлены временные диаграммы сигналов
стадий декодирования и планирования на выполнение.
На рисунке \ref{img:execution} представлены временные диаграммы сигналов
стадии выполнения.

\img{50mm}{fetch.pdf}{Выборка и диспетчеризация команды \#!}{fetch}

\img{75mm}{decode.pdf}{Декодирование и планирование на выполнение команды
\#!}{decode}

\img{75mm}{execution.pdf}{Выполнение команды \#!}{execution}

\section{Трасса выполнения программы}

На рисунке \ref{img:route} представлена трасса выполнения программы.

\img{130mm}{pipeline.pdf}{Трасса выполнения программы}{route}

Проанализировав трассу выполнения программы, можно сделать вывод о том, что
конфликты возникают тогда, когда блок обращения к памяти не успевает загрузить
необходимое для выполнения арифметической операции значение. Это происходит
потому, что блок обращения к памяти выполняет загрузку за три такта, а
арифметическая команда следует за загрузкой нужной переменной через одну
команду, таким образом блок обращения к памяти завершает только 2 такта
обработки.

\section{Оптимизация программы}

Хотя блок обращения к памяти выполняет команду за 3 такта, он может принимать
команду на вход каждый такт, таким образом, при последовательном расположении
команд загрузки мы сможем увеличить количество команд между загрузкой и
арифметической операцией, исключив возникающие конфликты и недопустив новые.

На листинге \ref{lst:var12opt} приведен текст оптимизированной программы по
индивидуальному варианту.

\mylisting{Текст оптимизированной программы по индивидуальному
варианту}{var12opt}{1-33}{var12opt.s}

На листиге \ref{lst:optPseudo} приведен псевдокод на языке C, соответствующий
оптимизированной программе варианта.

\mylisting{Псевдокод на языке C оптимизированной программы
варианта}{optPseudo}{1-29}{optPseudo.c}

На листиге \ref{lst:optHex} приведен дизассемблерный код оптимизированной
программы.

\mylisting{Дизассемблерный листинг}{optHex}{1-20}{optHex.txt}

На рисунке \ref{img:optRoute} представлена трасса выполнения оптимизированной
программы.

\img{120mm}{pipelineOpt.pdf}{Трасса выполнения оптимизированной
программы}{optRoute}

\section{Вывод}

При выполнении неоптимизированной программы вычисления завершаются за 41
такт, при выполнении оптимизированной -- за 37 (без учета бесконечного цикла).
Таким образом, в результате оптимизации удалось сократить выполнение на 4
такта, то есть получилось ускорить программу на
$\frac{4}{41} \approx 0.1 (10\%)$

